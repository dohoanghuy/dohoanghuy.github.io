"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[1980],{277(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"oop/TDD/tdd","title":"TDD Flow","description":"Create a doc page with rich content.","source":"@site/docs/oop/TDD/tdd.md","sourceDirName":"oop/TDD","slug":"/oop/TDD/","permalink":"/docs/oop/TDD/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/oop/TDD/tdd.md","tags":[{"inline":true,"label":"tdd","permalink":"/docs/tags/tdd"},{"inline":true,"label":"test driven development (kent beck), xUnit test pattern, growing object oriented guided by test","permalink":"/docs/tags/test-driven-development-kent-beck-x-unit-test-pattern-growing-object-oriented-guided-by-test"}],"version":"current","frontMatter":{"description":"Create a doc page with rich content.","tags":["tdd","test driven development (kent beck), xUnit test pattern, growing object oriented guided by test"]},"sidebar":"oopSidebar","previous":{"title":"Dependency inversion principle","permalink":"/docs/oop/SOLID/dependency-inversion-principle"},"next":{"title":"TDD Knowledge Base","permalink":"/docs/oop/TDD/intro"}}');var o=n(4848),s=n(8453);const r={description:"Create a doc page with rich content.",tags:["tdd","test driven development (kent beck), xUnit test pattern, growing object oriented guided by test"]},a="TDD Flow",l={},c=[{value:"RED",id:"red",level:2},{value:"GREEN",id:"green",level:2},{value:"YELLOW",id:"yellow",level:2},{value:"CLEAN TEST",id:"clean-test",level:2},{value:"TEST DESIGN",id:"test-design",level:2},{value:"TEST PROCESS (dig a hole)",id:"test-process-dig-a-hole",level:2},{value:"TRANSFORMATION PRIORITY PREMISE",id:"transformation-priority-premise",level:2}];function h(e){const t={blockquote:"blockquote",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"tdd-flow",children:"TDD Flow"})}),"\n",(0,o.jsx)(t.p,{children:"RED - GREEN - YELLOW"}),"\n",(0,o.jsx)(t.p,{children:"Step by step, from generic  to specific with incremental algorithmics. Only do simple change at a step"}),"\n",(0,o.jsx)(t.p,{children:"As the test gets more specific, the code gets more generic"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Nature of test, it's not fully constrain a program, it not specify the final behavior (only specify the desire of human). It only prove the program wrong, it's can't prove the program right."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"red",children:"RED"}),"\n",(0,o.jsx)(t.p,{children:"Write failed test first. Write the generic test case first (it's will danger for speficic testcase cause make production code generic, which might got stuck when test gradualy develop => you have to write testcase in correct order)"}),"\n",(0,o.jsx)(t.p,{children:"Migh be struggle, getting stuck (because exiting production so specific)."}),"\n",(0,o.jsx)(t.p,{children:"Triple A rule (Arrange - Act - Assert - [clean up/tear down])."}),"\n",(0,o.jsx)(t.p,{children:"Arrange is setup the state for the test. Setup the test fixture: transisent fresh, persistent fresh, persistent shared. Using test hirecy to keep our setup manageable"}),"\n",(0,o.jsx)(t.p,{children:"Act is calling the funtion to be tested. Single/Multiple/Compose action"}),"\n",(0,o.jsx)(t.p,{children:"Assert is test the function to the right things. Single (logical) assertion rule: 1 test should have only 1 logical assert (logical assert represent by several physical assert). Not violate the rule by: Arrange -> Act -> Assert -> Act -> Assert -> Act -> Assert ... Test should be independences & isolation, we shouldn't take output of a test as input of other test"}),"\n",(0,o.jsx)(t.p,{children:"Annihilate"}),"\n",(0,o.jsx)(t.p,{children:"Clean Composition to make the test clean, readable"}),"\n",(0,o.jsx)(t.h2,{id:"green",children:"GREEN"}),"\n",(0,o.jsx)(t.p,{children:"Write production code to make it pass"}),"\n",(0,o.jsx)(t.p,{children:"Try to make very small change to make it pass"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"if (specific) => loop while/foor (generic)"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Insome case, you might stuck at the middle, which make you have to rewrite lot of production code => stuck. Recommendation is to restart with testcase again"}),"\n",(0,o.jsx)(t.h2,{id:"yellow",children:"YELLOW"}),"\n",(0,o.jsx)(t.p,{children:"Refactor production/test code"}),"\n",(0,o.jsx)(t.h2,{id:"clean-test",children:"CLEAN TEST"}),"\n",(0,o.jsx)(t.h2,{id:"test-design",children:"TEST DESIGN"}),"\n",(0,o.jsx)(t.p,{children:"Should 1 test file per class. Inner class (is exception case) normaly the result of refactoring, it shouldn't usually change the structure of the test to reflect of the refactor. The test test behavior of the outer class, the way behavior implemented is not of the test business (if I have to write a private function, i'm not going to let the test known that). If we refactoring to several new outer class (which used by other place) => we should imp test for it."}),"\n",(0,o.jsx)(t.p,{children:"Avoid fragile test by apply SOLID"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"SRP: test should have single responsibility (for single class)"}),"\n",(0,o.jsx)(t.li,{children:"OCP: prod code open for extend modification, test close for modify. Test shouldn't have knownledge it shouldn't have"}),"\n",(0,o.jsx)(t.li,{children:"LSP: polymophism (test is client of production code)"}),"\n",(0,o.jsx)(t.li,{children:"ISP: protect from to much knownledge (test is client of production code)"}),"\n",(0,o.jsx)(t.li,{children:"DIP: test is low level detail, test is depend on prod code"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"To known what test to write first? Think about what code you will write first. Let the code help you what test to write, list out the todo test (plan ahead a little bit). Using pattern ex: given_when_then"}),"\n",(0,o.jsx)(t.h2,{id:"test-process-dig-a-hole",children:"TEST PROCESS (dig a hole)"}),"\n",(0,o.jsx)(t.p,{children:"Start write simple test, treat each test as star to step down for further test (then you can remove simple star step test later)"}),"\n",(0,o.jsx)(t.p,{children:"Assert first, it pull the rest of the test to the being by => deal with compiler error, execution error. This backward technique help build test from the back all the way to the begining"}),"\n",(0,o.jsx)(t.p,{children:"Triangulation: The way we create genericnation. One to many technique"}),"\n",(0,o.jsx)(t.p,{children:"The two disks story : 1 for test, 1 for prod code. If 1 of them destroyed, which want you expect to keep. In fact you can revert prod code from the test (not reverse)"}),"\n",(0,o.jsx)(t.p,{children:"Good test - Test are specifications. It should read as a documentation (write the test that you want to read, write to the audience). Test the behavior, not the API"}),"\n",(0,o.jsx)(t.p,{children:"Test come first:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"express all the ideas the author want to express"}),"\n",(0,o.jsx)(t.li,{children:"pass all the test"}),"\n",(0,o.jsx)(t.li,{children:"no duplication in code"}),"\n",(0,o.jsx)(t.li,{children:"minimize the class & method"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Kent Beck says:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"first make it work"}),"\n",(0,o.jsx)(t.li,{children:"then make it right"}),"\n",(0,o.jsx)(t.li,{children:"then make it fast & small"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Heresy"}),"\n",(0,o.jsx)(t.h2,{id:"transformation-priority-premise",children:"TRANSFORMATION PRIORITY PREMISE"}),"\n",(0,o.jsx)(t.p,{children:"Transformation is the counter part of refactoring, they are small change to the code that change habavior but reverse structure."}),"\n",(0,o.jsx)(t.p,{children:"Refactoring changing the structure without significant change in behavior\nChange the behavior without significant change in the structure? => transformation"}),"\n",(0,o.jsx)(t.p,{children:"Do transformantion in Red/Green/Refactor cycle.\nMaking the test pass => change behavior, not structure\nLater on refactor => change the structure, not behavior"}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"As the test gets more specific, the code gets more generic"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Transformations:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"null: use to represent initial state of any function"}),"\n",(0,o.jsx)(t.li,{children:"null to constant: use to return something"}),"\n",(0,o.jsx)(t.li,{children:"constant to variale: to enable later sequence of transformations"}),"\n",(0,o.jsx)(t.li,{children:"add computation: add 1 or more computation to intialize variable but not change the state of variable"}),"\n",(0,o.jsx)(t.li,{children:"split the flow of control: adding if statment to split flow into 2 & only 2 path"}),"\n",(0,o.jsx)(t.li,{children:"variable to array: use want you have more then 1 assumption on the same thing (one to many*)"}),"\n",(0,o.jsx)(t.li,{children:"array to container: use when generalize an array to more comprehensive like dictionary or set"}),"\n",(0,o.jsx)(t.li,{children:"convert if (specific form of while) to while (general form of if): use when realize the flow has already been split but now also repeated (+remove duplicate code)"}),"\n",(0,o.jsx)(t.li,{children:"recurse: use want to repeat execution"}),"\n",(0,o.jsx)(t.li,{children:"itegration: use when want to repeat but don't want use (9) in some reason"}),"\n",(0,o.jsx)(t.li,{children:"assign: use want to alter the state of existing previous variable (be careful for begining of state)"}),"\n",(0,o.jsx)(t.li,{children:"add case: use when we have split flow & want to split further"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Sometime, you will get bad algorithm (time complexity). If we choose transformation with right priority, we get better algorithms (sorting list example*). Try to apply transformation order from 1-12 to make the test pass will make you have better algorithm. Those transformation order by complexity, higher transformation is simpler and have low impact to the code, lower transformation is complicated and have high impact to the code."}),"\n",(0,o.jsx)(t.p,{children:"Apply complex transformation early might cause TDD stuck cause start implement prod code in specific. The suggestion to write test can be solve by higher tranformation first"})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453(e,t,n){n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const o={},s=i.createContext(o);function r(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);